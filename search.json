[{"title":"Python ssh桥连mysql","url":"/2022/04/21/111/","content":"Code only, Mark for the next usage.Requires:\npymysql\nsshtunnel\n\nMySql Class:\nimport pymysqlfrom sshtunnel import SSHTunnelForwarderclass MySql:    def __init__(self):        self.server = SSHTunnelForwarder(            ssh_address_or_host=(&#x27;SSH IP-ADDRESS&#x27;, 22),  # 指定ssh登录的跳转机的address            ssh_username=&#x27;root&#x27;,  # 跳转机的用户            ssh_password=&#x27;PWD&#x27;,  # 跳转机的密码            remote_bind_address=(&#x27;DB HOST&#x27;,                                 3306))        self.server.start()        self.conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, # 用了ssh桥连，这里固定                                    port=self.server.local_bind_port,                                    user=&#x27;root&#x27;,                                    password=&#x27;PWD&#x27;,                                    db=&#x27;DB-NAME&#x27;,                                    charset=&#x27;utf8&#x27;)        self.cursor = self.conn.cursor()    def insert(self, sql):        try:            self.cursor.execute(sql)            self.conn.commit()        except Exception as e:            print(e)            self.conn.rollback()    def close(self):        self.server.stop()        self.cursor.close()        self.conn.close()    def select(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchall()        except Exception as e:            print(e)            return None    def update(self, sql):        try:            self.cursor.execute(sql)            self.conn.commit()        except Exception as e:            print(e)            self.conn.rollback()    def delete(self, sql):        try:            self.cursor.execute(sql)            self.conn.commit()        except Exception as e:            print(e)            self.conn.rollback()    def select_one(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchone()        except Exception as e:            print(e)            return None    def select_many(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchmany()        except Exception as e:            print(e)            return None    def select_all(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchall()        except Exception as e:            print(e)            return None    def select_count(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchone()[0]        except Exception as e:            print(e)            return None    def insert_many(self, sql, values):        try:            self.cursor.executemany(sql, values)            self.conn.commit()        except Exception as e:            self.conn.rollback()            raise e\n\n","categories":["Python"],"tags":["Python","Mysql","pymysql","SQL"]},{"title":"Being or Been","url":"/2022/04/02/Being-or-Been/","content":"Being 是 BE 动词的现在分词，而 Been 是 BE 动词的过去分词。\nbeen 一定用在 have (及其他 have 形式，如 has, had, will have 等) 之后，而 being 绝不会用在 have 之后。 Being 是用在 BE 动词之后 (及其他 be 形式，如 are, were, is, was 等) \nExample:\nShe is being very clever today. (Correct)                                              她今天表现的很聪明\nShe has being very clever today. (Incorrect)\nThey have been busy.  (Correct)                                                           他们一直很忙\nThey are been busy. (Incorrect)\nSophia has being working at that company.  (Incorrect) － being 不能在 have 或 has 后。\n\nBeing 可用作名词Example:\nA human being (人，人类)\nA strange being stepped out of the spaceship. (一个奇怪的人走出了太空船)\n\nBeing 也可用作动名词。Example:\nDo you like being so careless? (你喜欢这么粗心吗？)\nThe accident was caused by his being so clumsy. (因为他的不熟练才导致了这起事故)\nI live in terror of not being misunderstood. (我活在不被误解的恐惧中)。出自英国大文豪王尔德 (Oscar Wilde)\n\n一般而言，现在分词和过去分词都可以当形容词来修饰名词，但 being 和 been 不行Example:\nBroken vase 破碎的花瓶 (Correct)\nDeleted file 删除的文件 (Correct)\nJogging girl 跑步的少女 (正)\nThe been car  (Incorrect,meaningless)\nThe being flower  (Incorrect,meaningless)\n\n","categories":["English"],"tags":["English"]},{"title":"ES6 循环","url":"/2021/10/23/ES6-%E5%BE%AA%E7%8E%AF/","content":"// 循环下标或者key（for-in）  // do not actually do thisfor (var index in myArray) &#123;      console.log(myArray[index]);  &#125;    // 循环value（for-of）  for (var value of myArray) &#123;    console.log(value);  &#125;    // 甚至直接循环key和value，no problem  for (var [key, value] of phoneBookMap) &#123;    console.log(key + &quot;&#x27;s phone number is: &quot; + value);  &#125;  \n\n","categories":["Javascript"],"tags":["ES6"]},{"title":"Easy forget words in Mar 2022","url":"/2022/03/22/Easy-forget-words-in-Mar-2022/","content":"Nouns about academic which easy to forget\narchaeology: 考古学\narchitecture: 建筑学&#x2F; 结构，体系结构\nagriculture: 农学\nWords with silent ‘w’\nwrestle: 摔跤&#x2F;打架\nwrinkle: 褶皱**&#x2F;**皱纹\n","categories":["English"]},{"title":"Http请求方式","url":"/2022/04/12/Http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/","content":"\nGET从服务器获取资源\n\nHEADHEAD和GET类似，只是服务器的响应中只返回头部（没有实体部分）；在不获取资源情况下了解资源的状况\n\nPOST在服务器创建资源\n\nPUT在服务器修改资源，同一个url多次请求只修改一次\n\nDELETE在服务器删除资源，同一个url多次请求只删除一次\n\nOPTIONS跨域时复杂请求\n\n使用了 put&#x2F;delete&#x2F;connnect&#x2F;trace&#x2F;patch\n人为设置了一些header字段\ncontent-type的值不属于：application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain\n\n\nTRACE 用于显示调试信息多数网站不支持，会泄露一些调试信息或者只有内部的时候才支持，它能帮助你追述整个http的链路，假如http发出去，它可能接收第一个不是网关； 它可能是代理服务器，再通过负载均衡才到达你真实的服务器，这里面有一定的路径，trace可以帮助我们请求http协议的网址时协议调试信息\n\nCONNECT代理\n\nPATCH对资源进行部分更新\n\n\n","categories":["网络协议"],"tags":["HTTP"]},{"title":"Personal Opinion About \"Check in\" Form","url":"/2022/04/14/Personal-Opinion-About-Check-in-Form/","content":"  I’ve seen too many people record their learning, working or gym, etc. which they intend to persist in it on WeChat Moments, But I hardly see any of them still keeping it when one week passes or earlier.  *IMO, It seems more like a sort of ritual for them than their initial purpose; It will be redundant and waste time for people who actually want to become better; Honestly, it really needs extremely determination to keep firm until we achieve succeed\n","categories":["English"],"tags":["English"]},{"title":"Python Cloudscraper Request请求HTML过CloudFlare检测","url":"/2022/04/21/Python-Cloudscraper-Request%E8%AF%B7%E6%B1%82HTML%E8%BF%87CloudFlare%E6%A3%80%E6%B5%8B/","content":"Python Cloudscraper Request请求HTML过CloudFlare检测上一篇使用无头浏览器，在部署到服务器上时遇到了难题–由于服务器配置过低，但无头浏览器的webdriver cpu占用略高，双线程开两个cpu就吃满了，所以打算换一种思路，使用直接request请求\n刚准备写这个爬虫时，本是打算用request请求爬取静态资源解析的思路做的，但尝试后发现会被CloudFlare等工具检测并拦截.\n用了cloudscraper发送请求，现在可以过检测了，相比于无头浏览器，更加节省资源\n代码：\nimport cloudscraper    def cloudflare_get(self, url, proxies=None):        retry = 6        while retry &gt; 0:            try:                res = cloudscraper.create_scraper().get(url,                                                        proxies=proxies,                                                        timeout=20)                # print(res.text)                return res            # except cloudscraper.exceptions.CloudflareIUAMError:            except Exception as e:                print(f&#x27;cloudflare get failed on &#123;e&#125;, retrying&#x27;)                logging.error(&#x27;cloudflare get failed on %s&#x27;, e)                retry = retry - 1                time.sleep(5)                        raise Exception(f&#x27;cloudflare get &#123;url&#125; failed&#x27;)\n\n未来做爬虫时，对于不涉及复杂操作的爬取需求，一律采取静态资源爬取的方式，占用资源小，效率高。无头浏览器针对于存在复杂操作逻辑时才需要使用","categories":["Python"],"tags":["Python","Spider","CloudFlare","Cloudscraper"]},{"title":"Python selenium 无头浏览器过CloudFlare","url":"/2022/04/21/Python-selenium-%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%87CloudFlare/","content":"使用 undetected_chromedriver chrome驱动from selenium.webdriver.chrome.options import Optionsfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byimport undetected_chromedriver as uc                          chrome_options = Options() chrome_options.add_argument(&#x27;--headless&#x27;)        # chrome_options.add_argument(        #     &#x27;user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&quot;&#x27;        # )self.driver = uc.Chrome(chrome_options)        # 测试后发现使用Undetected Chromedrive 不需要注入js        # with open(&#x27;./stealth.min.js&#x27;) as f:        #     js = f.read()        # self.driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;,        #                             &#123;&quot;source&quot;: js&#125;)\n\n","categories":["Python"],"tags":["Python","Spider"]},{"title":"TCP/IP三次握手","url":"/2022/04/12/TCP-IP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","content":"\n","categories":["网络协议"],"tags":["TCP/IP"]},{"title":"Difference between Suffcient,Adequate and Enough","url":"/2022/03/28/Untitled/","content":"Firstly,grammarly,’adequate’ could not use before the noun in the plural(名词复数),but the others can\nSecondly,\n​    ‘Adequate’ refers barely enough,just enough,nothing remain except we need\n​    ’Sufficent’ means remain a little bit except we need\n​    ‘Enough’ means a quite amount remain except we need\n","categories":["English"],"tags":["Word Contrast"]},{"title":"map与foreach","url":"/2021/11/11/map%E4%B8%8E-foreach/","content":"区别？Array.forEach()改变原数组，Array.map()则不改变原数组，返回新对象，但在实践中，发现只有基础数据类型不会被改变，引用数据类型则还是会被改变。\n例:\nlet a = [1,2,3,4,5]a.map(n =&gt; &#123;  n = n * 2&#125;)console.log(a) // [1, 2, 3, 4, 5]let b = [&#123; a: 1 &#125;, &#123; a: 2 &#125;, &#123; a: 3 &#125;, &#123; a: 4 &#125;, &#123; a: 5 &#125;]b.map((v) =&gt; &#123;  v.a = v.a * 2&#125;)console.log(JSON.stringify(b)) // [&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:4&#125;,&#123;&quot;a&quot;:6&#125;,&#123;&quot;a&quot;:8&#125;,&#123;&quot;a&quot;:10&#125;]\n\n以下内容摘取CSDNmap():map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值\n也就是map()进行处理之后返回一个新的数组\n⚠️注意：map()方法不会对空数组进行检测\nmap方法不会改变原始数组\nforEach()\nforEach方法用于调用数组的每个元素，将元素传给回调函数\n⚠️注意： forEach对于空数组是不会调用回调函数的 ，\n没有返回一个新数组&amp;没有返回值\n应用场景：为一些相同的元素，绑定事件处理器！\n不可链式调用\n执行速度摘自CSDNjsPref是一个非常好的网站用来比较不同的JavaScript函数的执行速度。\n这里是forEach()和map()的测试结果：\n可以看到，在我到电脑上forEach()的执行速度比map()慢了70%。每个人的浏览器的执行结果会不一样。你可以使用下面的链接来测试一下: Map vs. forEach - jsPref。\nJavaScript太灵活了，出了BUG你也不知道，不妨接入Fundebug线上实时监控。\n函数式角度的理解\n如果你习惯使用函数是编程，那么肯定喜欢使用map()。因为forEach()会改变原始的数组的值，而map()会返回一个全新的数组，原本的数组不受到影响。\n哪个更好呢？\n取决于你想要做什么。\nforEach适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。\n理解map性能强于forEach，且能链式操作，forEach适合不改变数据，只想拿数据做一些判断时对数据做操作优先用map\n","categories":["Javascript"],"tags":["VanillaJs","Map","Foreach"]},{"title":"终端常用命令","url":"/2022/03/29/%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"查看程序进程IDps -ef | grep [Process Name]\n\n查看监听该端口的进程sudo lsof -nP | grep LISTEN | grep [Port]# orsudo lsof -i :[Port]\n\n查看该进程占用的端口sudo lsof -nP -p [Process ID] | grep LISTEN\n\n杀死进程kill -9 [Process ID]\n\n","categories":["Linux"],"tags":["Linux","Shell"]},{"title":"闭包的理解","url":"/2021/10/21/%E9%97%AD%E5%8C%85/","content":"问题function fun(n,o) &#123;  console.log(o)  return &#123;    fun:function(m)&#123;      return fun(m,n);    &#125;  &#125;;&#125;var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?//问:三行a,b,c的输出分别是什么？\n\n解析第一行var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\n\n分析：首先，这一行代码为“;”分割，所以，var a一旦定义，后续调用fun方法不会在改变本身，m,n的作用域也属于a，所以fun(0) &#x3D;&gt; undefined, 此时的a实际为：\nvar a = function fun(n,0) &#123;  console.log(0)  return &#123;    fun:function(m)&#123;      return fun(m,n);    &#125;  &#125;;&#125;\n\n所以不管是a.fun(x),输出的值都是0\n第二行var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\n\n分析：这一行为连续执行，所以每一次掉的fun都为上次执行返回的对象，也就是\n&#123;  fun: (m) &#123;    return fun(m,n)  &#125;&#125;\n\n其n的作用域总为上一次调用此方法传入的第一个参数，所以，答案为：\n// undefined,0,1,2\n\n第三行var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n\n第三行懒得说了，一样的道理\n","categories":["Javascript"],"tags":["VanillaJs"]}]