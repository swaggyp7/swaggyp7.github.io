[{"title":"ES6 循环","url":"/2021/10/23/ES6-%E5%BE%AA%E7%8E%AF/","content":"// 循环下标或者key（for-in）  // do not actually do thisfor (var index in myArray) &#123;      console.log(myArray[index]);  &#125;    // 循环value（for-of）  for (var value of myArray) &#123;    console.log(value);  &#125;    // 甚至直接循环key和value，no problem  for (var [key, value] of phoneBookMap) &#123;    console.log(key + &quot;&#x27;s phone number is: &quot; + value);  &#125;  \n\n","categories":["Javascript"],"tags":["ES6"]},{"title":"Difference between Suffcient,Adequate and Enough","url":"/2022/03/28/Untitled/","content":"Firstly,grammarly,’adequate’ could not use before the noun in the plural(名词复数),but the others can\nSecondly,\n​    ‘Adequate’ refers barely enough,just enough,nothing remain except we need\n​    ’Sufficent’ means remain a little bit except we need\n​    ‘Enough’ means a quite amount remain except we need\n","categories":["English"],"tags":["Word Contrast"]},{"title":"Easy forget words in Mar 2022","url":"/2022/03/22/Easy-forget-words-in-Mar-2022/","content":"Nouns about academic which easy to forget\narchaeology: 考古学\narchitecture: 建筑学&#x2F; 结构，体系结构\nagriculture: 农学\nWords with silent ‘w’\nwrestle: 摔跤&#x2F;打架\nwrinkle: 褶皱**&#x2F;**皱纹\n","categories":["English"]},{"title":"map与foreach","url":"/2021/11/11/map%E4%B8%8E-foreach/","content":"区别？Array.forEach()改变原数组，Array.map()则不改变原数组，返回新对象，但在实践中，发现只有基础数据类型不会被改变，引用数据类型则还是会被改变。\n例:\nlet a = [1,2,3,4,5]a.map(n =&gt; &#123;  n = n * 2&#125;)console.log(a) // [1, 2, 3, 4, 5]let b = [&#123; a: 1 &#125;, &#123; a: 2 &#125;, &#123; a: 3 &#125;, &#123; a: 4 &#125;, &#123; a: 5 &#125;]b.map((v) =&gt; &#123;  v.a = v.a * 2&#125;)console.log(JSON.stringify(b)) // [&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:4&#125;,&#123;&quot;a&quot;:6&#125;,&#123;&quot;a&quot;:8&#125;,&#123;&quot;a&quot;:10&#125;]\n\n以下内容摘取CSDNmap():map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值\n也就是map()进行处理之后返回一个新的数组\n⚠️注意：map()方法不会对空数组进行检测\nmap方法不会改变原始数组\nforEach()\nforEach方法用于调用数组的每个元素，将元素传给回调函数\n⚠️注意： forEach对于空数组是不会调用回调函数的 ，\n没有返回一个新数组&amp;没有返回值\n应用场景：为一些相同的元素，绑定事件处理器！\n不可链式调用\n执行速度摘自CSDNjsPref是一个非常好的网站用来比较不同的JavaScript函数的执行速度。\n这里是forEach()和map()的测试结果：\n可以看到，在我到电脑上forEach()的执行速度比map()慢了70%。每个人的浏览器的执行结果会不一样。你可以使用下面的链接来测试一下: Map vs. forEach - jsPref。\nJavaScript太灵活了，出了BUG你也不知道，不妨接入Fundebug线上实时监控。\n函数式角度的理解\n如果你习惯使用函数是编程，那么肯定喜欢使用map()。因为forEach()会改变原始的数组的值，而map()会返回一个全新的数组，原本的数组不受到影响。\n哪个更好呢？\n取决于你想要做什么。\nforEach适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。\n理解map性能强于forEach，且能链式操作，forEach适合不改变数据，只想拿数据做一些判断时对数据做操作优先用map\n","categories":["Javascript"],"tags":["VanillaJs","Map","Foreach"]},{"title":"终端常用命令","url":"/2022/03/29/%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"查看程序进程IDps -ef | grep [Process Name]\n\n查看监听该端口的进程sudo lsof -nP | grep LISTEN | grep [Port]# orsudo lsof -i :[Port]\n\n查看该进程占用的端口sudo lsof -nP -p [Process ID] | grep LISTEN\n\n杀死进程kill -9 [Process ID]\n\n","categories":["Linux"],"tags":["Linux","Shell"]},{"title":"闭包的理解","url":"/2021/10/21/%E9%97%AD%E5%8C%85/","content":"问题function fun(n,o) &#123;  console.log(o)  return &#123;    fun:function(m)&#123;      return fun(m,n);    &#125;  &#125;;&#125;var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?//问:三行a,b,c的输出分别是什么？\n\n解析第一行var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\n\n分析：首先，这一行代码为“;”分割，所以，var a一旦定义，后续调用fun方法不会在改变本身，m,n的作用域也属于a，所以fun(0) &#x3D;&gt; undefined, 此时的a实际为：\nvar a = function fun(n,0) &#123;  console.log(0)  return &#123;    fun:function(m)&#123;      return fun(m,n);    &#125;  &#125;;&#125;\n\n所以不管是a.fun(x),输出的值都是0\n第二行var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\n\n分析：这一行为连续执行，所以每一次掉的fun都为上次执行返回的对象，也就是\n&#123;  fun: (m) &#123;    return fun(m,n)  &#125;&#125;\n\n其n的作用域总为上一次调用此方法传入的第一个参数，所以，答案为：\n// undefined,0,1,2\n\n第三行var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n\n第三行懒得说了，一样的道理\n","categories":["Javascript"],"tags":["VanillaJs"]}]