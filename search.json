[{"title":"Python ssh桥连mysql","url":"/2022/04/21/111/","content":"Code only, Mark for the next usage.Requires:\npymysql\nsshtunnel\n\nMySql Class:\nimport pymysqlfrom sshtunnel import SSHTunnelForwarderclass MySql:    def __init__(self):        self.server = SSHTunnelForwarder(            ssh_address_or_host=(&#x27;SSH IP-ADDRESS&#x27;, 22),  # 指定ssh登录的跳转机的address            ssh_username=&#x27;root&#x27;,  # 跳转机的用户            ssh_password=&#x27;PWD&#x27;,  # 跳转机的密码            remote_bind_address=(&#x27;DB HOST&#x27;,                                 3306))        self.server.start()        self.conn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, # 用了ssh桥连，这里固定                                    port=self.server.local_bind_port,                                    user=&#x27;root&#x27;,                                    password=&#x27;PWD&#x27;,                                    db=&#x27;DB-NAME&#x27;,                                    charset=&#x27;utf8&#x27;)        self.cursor = self.conn.cursor()    def insert(self, sql):        try:            self.cursor.execute(sql)            self.conn.commit()        except Exception as e:            print(e)            self.conn.rollback()    def close(self):        self.server.stop()        self.cursor.close()        self.conn.close()    def select(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchall()        except Exception as e:            print(e)            return None    def update(self, sql):        try:            self.cursor.execute(sql)            self.conn.commit()        except Exception as e:            print(e)            self.conn.rollback()    def delete(self, sql):        try:            self.cursor.execute(sql)            self.conn.commit()        except Exception as e:            print(e)            self.conn.rollback()    def select_one(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchone()        except Exception as e:            print(e)            return None    def select_many(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchmany()        except Exception as e:            print(e)            return None    def select_all(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchall()        except Exception as e:            print(e)            return None    def select_count(self, sql):        try:            self.cursor.execute(sql)            return self.cursor.fetchone()[0]        except Exception as e:            print(e)            return None    def insert_many(self, sql, values):        try:            self.cursor.executemany(sql, values)            self.conn.commit()        except Exception as e:            self.conn.rollback()            raise e\n\n","categories":["Python"],"tags":["Python","Mysql","pymysql","SQL"]},{"title":"Being or Been","url":"/2022/04/02/Being-or-Been/","content":"Being 是 BE 动词的现在分词，而 Been 是 BE 动词的过去分词。\nbeen 一定用在 have (及其他 have 形式，如 has, had, will have 等) 之后，而 being 绝不会用在 have 之后。 Being 是用在 BE 动词之后 (及其他 be 形式，如 are, were, is, was 等) \nExample:\nShe is being very clever today. (Correct)                                              她今天表现的很聪明\nShe has being very clever today. (Incorrect)\nThey have been busy.  (Correct)                                                           他们一直很忙\nThey are been busy. (Incorrect)\nSophia has being working at that company.  (Incorrect) － being 不能在 have 或 has 后。\n\nBeing 可用作名词Example:\nA human being (人，人类)\nA strange being stepped out of the spaceship. (一个奇怪的人走出了太空船)\n\nBeing 也可用作动名词。Example:\nDo you like being so careless? (你喜欢这么粗心吗？)\nThe accident was caused by his being so clumsy. (因为他的不熟练才导致了这起事故)\nI live in terror of not being misunderstood. (我活在不被误解的恐惧中)。出自英国大文豪王尔德 (Oscar Wilde)\n\n一般而言，现在分词和过去分词都可以当形容词来修饰名词，但 being 和 been 不行Example:\nBroken vase 破碎的花瓶 (Correct)\nDeleted file 删除的文件 (Correct)\nJogging girl 跑步的少女 (正)\nThe been car  (Incorrect,meaningless)\nThe being flower  (Incorrect,meaningless)\n\n","categories":["English"],"tags":["English"]},{"title":"ES6 循环","url":"/2021/10/23/ES6-%E5%BE%AA%E7%8E%AF/","content":"// 循环下标或者key（for-in）  // do not actually do thisfor (var index in myArray) &#123;      console.log(myArray[index]);  &#125;    // 循环value（for-of）  for (var value of myArray) &#123;    console.log(value);  &#125;    // 甚至直接循环key和value，no problem  for (var [key, value] of phoneBookMap) &#123;    console.log(key + &quot;&#x27;s phone number is: &quot; + value);  &#125;  \n\n","categories":["Javascript"],"tags":["ES6"]},{"title":"Easy forget words in Mar 2022","url":"/2022/03/22/Easy-forget-words-in-Mar-2022/","content":"Nouns about academic which easy to forget\narchaeology: 考古学\narchitecture: 建筑学&#x2F; 结构，体系结构\nagriculture: 农学\nWords with silent ‘w’\nwrestle: 摔跤&#x2F;打架\nwrinkle: 褶皱**&#x2F;**皱纹\n","categories":["English"]},{"title":"Github Copilot 使用体验","url":"/2022/04/21/Github-Copilot-%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/","content":"\n重复，繁琐的事情交给机器，把时间花在这些事情上没有任何意义\n\nCopilot 是什么Copilot (https://copilot.github.com/open in new window) 是由 Github 提供的AI编码辅助工具，它可以在编码过程中提供基于 AI 学习的编码建议。在很多情况下，只需要有注释或者函数名称，Copilot就可以实例完整的代码。\n目前 Copilot 还没有全量开放，需要申请开通权限。访问它的官方网站https://copilot.github.com/open in new window，点击“Sign up“按钮即可申请开通。当获得开通权限后，就可以在 Github 上使用 Copilot。\n\n安装插件在Vscode插件菜单中，搜索Copilot，安装即可\n插件市场的地址为https://marketplace.visualstudio.com/items?itemName=GitHub.copilot\n\n安装后插件会提示要求登录 [拥有体验资格的] Github 账户,根据提示登录即可\n资格去官网([https://copilot.github.com)申请，大概需要排队一个月的时间\n使用正常使用时，当 Copilot 给出建议时，会在光标位置的后方出现建议的代码，并灰色字显示。如果不希望使用提示，则继续输入代码即可，如果希望使用提示的代码，按下 Tab 键即可。\n\n在 VSCode 中，Copilot 有一个图标，需要确认状态是打开的。当它的样子与其它图标类似，没有背景颜色时，表示是开启的，此时当你编辑代码文件的时候，Copilot会自动提示代码建议。当它有背景颜色（红色、深黄色等）时，表示是关闭的。如果要切换状态只要点击它，然后选择全局（Globally）即可。\n\n快捷键\n接受建议：Tab\n拒绝建议：Esc\n打开Copilot：Ctrl + Enter （会打开一个单独的面板，展示10个建议）\n下一条建议：Command + ]\n上一条建议：Command + [\n触发行内Copilot：Command + \\ （Coplit还没有给出建议或者建议被拒绝了，希望手工触发它提供建议）\n\n使用经验对于基本的数据操作，依靠注释Copilot会帮你搞定\nCopilot 通过我的上下文，猜测出了我想对哪个数组进行操作，找出我想要的东西后还帮我推进了结果数组中\n这次生成的代码我完全可以直接用，不需要任何改动，至少节省了3分钟的时间\n对于一些通用的类，可以让Copilot帮你直接生成, 只需要输入正确的文件名和类名\n支持任何语言,框架Python\nTypescript\nTypescript in Vue\nReact\n\nCss\n甚至是过时的Layui\nCopilot会根据上下文猜测你接下来需要做什么首先在按钮栏中加一个按钮\n\n然后在原本处理逻辑中按一下回车\n\n有了这么完美的搬砖机器，就可以把更多的时间用在思考，架构上，不需要去浪费时间写这种死代码了\n还是需要不断提升自己，难得是思路，架构，不是死代码，永远不要做这种毫无技术含量的事，否则在中国这样的大环境下，还轮不到机器代替你，就已经被愿意拿更少钱，做更多事的人给代替了\n","categories":["Github"],"tags":["Copilot","Github"]},{"title":"Http请求方式","url":"/2022/04/12/Http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/","content":"\nGET从服务器获取资源\n\nHEADHEAD和GET类似，只是服务器的响应中只返回头部（没有实体部分）；在不获取资源情况下了解资源的状况\n\nPOST在服务器创建资源\n\nPUT在服务器修改资源，同一个url多次请求只修改一次\n\nDELETE在服务器删除资源，同一个url多次请求只删除一次\n\nOPTIONS跨域时复杂请求\n\n使用了 put&#x2F;delete&#x2F;connnect&#x2F;trace&#x2F;patch\n人为设置了一些header字段\ncontent-type的值不属于：application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain\n\n\nTRACE 用于显示调试信息多数网站不支持，会泄露一些调试信息或者只有内部的时候才支持，它能帮助你追述整个http的链路，假如http发出去，它可能接收第一个不是网关； 它可能是代理服务器，再通过负载均衡才到达你真实的服务器，这里面有一定的路径，trace可以帮助我们请求http协议的网址时协议调试信息\n\nCONNECT代理\n\nPATCH对资源进行部分更新\n\n\n","categories":["网络协议"],"tags":["HTTP"]},{"title":"Personal Opinion About \"Check in\" Form","url":"/2022/04/14/Personal-Opinion-About-Check-in-Form/","content":"  I’ve seen too many people record their learning, working or gym, etc. which they intend to persist in it on WeChat Moments, But I hardly see any of them still keeping it when one week passes or earlier.  *IMO, It seems more like a sort of ritual for them than their initial purpose; It will be redundant and waste time for people who actually want to become better; Honestly, it really needs extremely determination to keep firm until we achieve succeed\n","categories":["English"],"tags":["English"]},{"title":"Python Cloudscraper Request请求HTML过CloudFlare检测","url":"/2022/04/21/Python-Cloudscraper-Request%E8%AF%B7%E6%B1%82HTML%E8%BF%87CloudFlare%E6%A3%80%E6%B5%8B/","content":"Python Cloudscraper Request请求HTML过CloudFlare检测上一篇使用无头浏览器，在部署到服务器上时遇到了难题–由于服务器配置过低，但无头浏览器的webdriver cpu占用略高，双线程开两个cpu就吃满了，所以打算换一种思路，使用直接request请求\n刚准备写这个爬虫时，本是打算用request请求爬取静态资源解析的思路做的，但尝试后发现会被CloudFlare等工具检测并拦截.\n用了cloudscraper发送请求，现在可以过检测了，相比于无头浏览器，更加节省资源\n代码：\nimport cloudscraper    def cloudflare_get(self, url, proxies=None):        retry = 6        while retry &gt; 0:            try:                res = cloudscraper.create_scraper().get(url,                                                        proxies=proxies,                                                        timeout=20)                # print(res.text)                return res            # except cloudscraper.exceptions.CloudflareIUAMError:            except Exception as e:                print(f&#x27;cloudflare get failed on &#123;e&#125;, retrying&#x27;)                logging.error(&#x27;cloudflare get failed on %s&#x27;, e)                retry = retry - 1                time.sleep(5)                        raise Exception(f&#x27;cloudflare get &#123;url&#125; failed&#x27;)\n\n未来做爬虫时，对于不涉及复杂操作的爬取需求，一律采取静态资源爬取的方式，占用资源小，效率高。无头浏览器针对于存在复杂操作逻辑时才需要使用","categories":["Python"],"tags":["Python","Spider","CloudFlare","Cloudscraper"]},{"title":"Python selenium 无头浏览器过CloudFlare","url":"/2022/04/21/Python-selenium-%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%87CloudFlare/","content":"使用 undetected_chromedriver chrome驱动from selenium.webdriver.chrome.options import Optionsfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byimport undetected_chromedriver as uc                          chrome_options = Options() chrome_options.add_argument(&#x27;--headless&#x27;)        # chrome_options.add_argument(        #     &#x27;user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&quot;&#x27;        # )self.driver = uc.Chrome(chrome_options)        # 测试后发现使用Undetected Chromedrive 不需要注入js        # with open(&#x27;./stealth.min.js&#x27;) as f:        #     js = f.read()        # self.driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;,        #                             &#123;&quot;source&quot;: js&#125;)\n\n","categories":["Python"],"tags":["Python","Spider"]},{"title":"TCP/IP三次握手","url":"/2022/04/12/TCP-IP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","content":"\n","categories":["网络协议"],"tags":["TCP/IP"]},{"title":"map与foreach","url":"/2021/11/11/map%E4%B8%8E-foreach/","content":"区别？Array.forEach()改变原数组，Array.map()则不改变原数组，返回新对象，但在实践中，发现只有基础数据类型不会被改变，引用数据类型则还是会被改变。\n例:\nlet a = [1,2,3,4,5]a.map(n =&gt; &#123;  n = n * 2&#125;)console.log(a) // [1, 2, 3, 4, 5]let b = [&#123; a: 1 &#125;, &#123; a: 2 &#125;, &#123; a: 3 &#125;, &#123; a: 4 &#125;, &#123; a: 5 &#125;]b.map((v) =&gt; &#123;  v.a = v.a * 2&#125;)console.log(JSON.stringify(b)) // [&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:4&#125;,&#123;&quot;a&quot;:6&#125;,&#123;&quot;a&quot;:8&#125;,&#123;&quot;a&quot;:10&#125;]\n\n以下内容摘取CSDNmap():map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值\n也就是map()进行处理之后返回一个新的数组\n⚠️注意：map()方法不会对空数组进行检测\nmap方法不会改变原始数组\nforEach()\nforEach方法用于调用数组的每个元素，将元素传给回调函数\n⚠️注意： forEach对于空数组是不会调用回调函数的 ，\n没有返回一个新数组&amp;没有返回值\n应用场景：为一些相同的元素，绑定事件处理器！\n不可链式调用\n执行速度摘自CSDNjsPref是一个非常好的网站用来比较不同的JavaScript函数的执行速度。\n这里是forEach()和map()的测试结果：\n可以看到，在我到电脑上forEach()的执行速度比map()慢了70%。每个人的浏览器的执行结果会不一样。你可以使用下面的链接来测试一下: Map vs. forEach - jsPref。\nJavaScript太灵活了，出了BUG你也不知道，不妨接入Fundebug线上实时监控。\n函数式角度的理解\n如果你习惯使用函数是编程，那么肯定喜欢使用map()。因为forEach()会改变原始的数组的值，而map()会返回一个全新的数组，原本的数组不受到影响。\n哪个更好呢？\n取决于你想要做什么。\nforEach适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。\n理解map性能强于forEach，且能链式操作，forEach适合不改变数据，只想拿数据做一些判断时对数据做操作优先用map\n","categories":["Javascript"],"tags":["VanillaJs","Map","Foreach"]},{"title":"终端常用命令","url":"/2022/03/29/%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"查看程序进程IDps -ef | grep [Process Name]\n\n查看监听该端口的进程sudo lsof -nP | grep LISTEN | grep [Port]# orsudo lsof -i :[Port]\n\n查看该进程占用的端口sudo lsof -nP -p [Process ID] | grep LISTEN\n\n杀死进程kill -9 [Process ID]\n\n","categories":["Linux"],"tags":["Linux","Shell"]},{"title":"给自己搭建一个node脚手架快速初始化项目","url":"/2022/06/20/%E7%BB%99%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAnode%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BF%AB%E9%80%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE/","content":"最近做的小型项目比较多，为了快速搭建项目，花一小时自己写了一个脚手架，下次再需要搭建相同类型项目时，只需要从模版选择就可以快速启动脚手架所用到的依赖\nchalk\ncommander  GitHub - tj&#x2F;commander.js: node.js command-line interfaces made easy\ndownload-git-repo\ninquirer  GitHub - SBoudrias&#x2F;Inquirer.js: A collection of common interactive command line user interfaces.\nora  GitHub - sindresorhus&#x2F;ora: Elegant terminal spinner\n\nStep1引入commander，并且创建控制台指令program  .version(    require(&quot;./package.json&quot;).version,    &quot;-v, --version&quot;,    &quot;output the current version&quot;  )  .command(&quot;create&quot;)  .descrip(tion(&quot;create a new project&quot;)\t.action(()=&gt; &#123;  // Do something after receive command&#125;)  // ...program.parse();\n\nStep2使用inquirer发起交互// ...initialize commander.action(() =&gt; &#123;    inquirer      .prompt([        &#123;          type: &quot;input&quot;,          name: &quot;name&quot;,          default: &quot;my-project&quot;,          message: &quot;🧐 Pleace input your project name&quot;,        &#125;,        &#123;          type: &quot;list&quot;,          name: &quot;type&quot;,          message: &quot;🧐 What type of project do you want to create?&quot;,          // list 类型需要填入选项          choices: [            &#123;              value: 1,              name: &quot;👉 Vue 3 + Typescript + Webpack 5 + Vant 3 + TailwindCss)&quot;,            &#125;,          ],        &#125;,      ])\n\nStep3对返回的所选项做相应的处理// ...const gitRepoMap = &#123;  1: &quot;direct:https://github.com/swaggyp7/TemplateForVue3Mobile.git&quot;,&#125;;.then((answers) =&gt; &#123;        const &#123; name, type &#125; = answers;  \t\t\t// 启动进度反馈        const proce = ora(&quot;Downloading template...&quot;);        proce.start();  \t\t\t// 使用download-git-repo克隆git模版仓库到本地\t\t\t\t// 这里的git仓库必须是这样的格式，否则会报错：  \t\t\t// direct:https://github.com/username/repository.git        download(gitRepoMap[type], name, &#123; clone: true &#125;, (err) =&gt; &#123;          if (err) &#123;            proce.fail(chalk.red(err));          &#125; else &#123;            proce.succeed(              chalk.greenBright(                &quot;🌟 Congratulation! Project created successfully!&quot;              )            );            // 这里可以去把package.json中的package name改为刚刚填入的package name            console.log(chalk.blue(chalk.bold(&quot;cd ./&quot; + name)));            console.log(chalk.blue(chalk.bold(&quot;yarn install&quot;)));            console.log(chalk.blue(chalk.bold(&quot;yarn serve&quot;)));          &#125;        &#125;);      &#125;);\n\n","categories":["NodeJs"],"tags":["NodeJs","Command","CLi"]},{"title":"闭包的理解","url":"/2021/10/21/%E9%97%AD%E5%8C%85/","content":"问题function fun(n,o) &#123;  console.log(o)  return &#123;    fun:function(m)&#123;      return fun(m,n);    &#125;  &#125;;&#125;var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?//问:三行a,b,c的输出分别是什么？\n\n解析第一行var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\n\n分析：首先，这一行代码为“;”分割，所以，var a一旦定义，后续调用fun方法不会在改变本身，m,n的作用域也属于a，所以fun(0) &#x3D;&gt; undefined, 此时的a实际为：\nvar a = function fun(n,0) &#123;  console.log(0)  return &#123;    fun:function(m)&#123;      return fun(m,n);    &#125;  &#125;;&#125;\n\n所以不管是a.fun(x),输出的值都是0\n第二行var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\n\n分析：这一行为连续执行，所以每一次掉的fun都为上次执行返回的对象，也就是\n&#123;  fun: (m) &#123;    return fun(m,n)  &#125;&#125;\n\n其n的作用域总为上一次调用此方法传入的第一个参数，所以，答案为：\n// undefined,0,1,2\n\n第三行var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n\n第三行懒得说了，一样的道理\n","categories":["Javascript"],"tags":["VanillaJs"]},{"title":"Nodejs Koa 接入Mysql+七牛云","url":"/2022/06/27/Nodejs-Koa-%E6%8E%A5%E5%85%A5Mysql-%E4%B8%83%E7%89%9B%E4%BA%91/","content":"Nodejs Koa 接入Mysql+七牛云站点地址: https://tmx.freesty1e.cn最近做了一个Web画廊应用，用于给女朋友展示作品集，后端服务用到了Koa+mysql接入七牛云存储静态图片，记录一下方便下次抄连接Mysql所用到的NPM依赖mysqltypeorm(将Typescript实体模型映射到数据库)reflect-metadata(Typeorm所需依赖)\n\nStep1创建ormconfig.json，配置数据库\n&#123;  &quot;type&quot;: &quot;mysql&quot;,  &quot;host&quot;: &quot;localhost&quot;,  &quot;port&quot;: 3306,  &quot;username&quot;: &quot;any&quot;,  &quot;password&quot;: &quot;***&quot;,  &quot;database&quot;: &quot;any&quot;,  &quot;synchronize&quot;: true, // 是否自动将实体模型同步到数据库  &quot;entities&quot;: [&quot;src/entity/*.ts&quot;], // 实体模型存放位置  &quot;cli&quot;: &#123;    &quot;entitiesDir&quot;: &quot;src/entity&quot;  &#125;&#125;\n\nStep2在程序入口引入 reflect-metadata，并且在创建Koa实例前建立Mysql连接\nimport &quot;reflect-metadata&quot;;import &#123; createConnection &#125; from &quot;typeorm&quot;;createConnection().then(()=&gt;&#123;  const app = new Koa();    // app.use(xxx)...     app.listen(3000);&#125;).catch((err: string) =&gt; console.log(&quot;Connection error&quot;, err));\n\nStep3在之前配置的实体模型目录下创建实体模型\nimport &#123; Entity, Column, PrimaryGeneratedColumn &#125; from &quot;typeorm&quot;;@Entity()export class Gallery &#123;  @PrimaryGeneratedColumn() // 自增主键  id: number;  @Column()  title: string;  @Column(&#123; length: 500 &#125;) // 注解可以传入配置参数  srcs: string;  @Column()  row: number;  @Column()  col: number;  @Column()  avatar: string;&#125;\n\nStep4配置完成后再连接数据库，会自动同步实体模型到数据库，如果没有对应表，会自动创建\n![image-20220627100312355](&#x2F;Users&#x2F;lin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220627100312355.png)\nCRUD代码 (这里用了bodyParser 解析参数)\nimport &#123; Context &#125; from &quot;koa&quot;;import &#123; Gallery &#125; from &quot;../entity/gallery&quot;;import &#123; getManager &#125; from &quot;typeorm&quot;;import CommeResponse from &quot;../entity/Response&quot;;import &#123; requireParams &#125; from &quot;../tools&quot;;export default class GalleryController &#123;  public static async list(ctx: Context) &#123;    const res = new CommeResponse();    const repository = getManager().getRepository(Gallery);    const gallerys = await repository.find();    res.data = gallerys;    res.msg = &quot;成功&quot;;    res.success = true;    ctx.status = res.code = 200;    ctx.body = res;  &#125;  public static async detail(ctx: Context) &#123;    const res = new CommeResponse();    const &#123; id &#125; = requireParams(&quot;id&quot;, ctx.request.body);    const galleryRepository = getManager().getRepository(Gallery);    const gallery = await galleryRepository.findOne(&#123; where: &#123; id &#125; &#125;);    if (gallery) &#123;      ctx.status = res.code = 200;      res.success = true;      res.msg = &quot;成功&quot;;      res.data = gallery;      ctx.body = res;    &#125; else &#123;      throw new Error(&quot;获取详情失败&quot;);    &#125;  &#125;  public static async add(ctx: Context) &#123;    const res = new CommeResponse();    const &#123; title, srcs, col, row, avatar &#125; = requireParams(      &quot;title,srcs&quot;,      ctx.request.body    );    const galleryRepository = getManager().getRepository(Gallery);    const gallery = new Gallery();    gallery.title = title;    gallery.srcs = srcs;    gallery.avatar = avatar ?? srcs.split(&quot;,&quot;)[0];    gallery.row = row ?? 1;    gallery.col = col ?? 1;    const sqlRes = await galleryRepository.insert(gallery);    if (sqlRes) &#123;      ctx.status = res.code = 200;      res.success = true;      res.msg = &quot;新增成功&quot;;      ctx.body = res;    &#125; else &#123;      throw new Error(&quot;新增失败&quot;);    &#125;  &#125;  public static async delete(ctx: Context) &#123;    const res = new CommeResponse();    const &#123; id &#125; = requireParams(&quot;id&quot;, ctx.request.body);    const galleryRepository = getManager().getRepository(Gallery);    await galleryRepository.delete(id);    res.success = true;    res.msg = &quot;删除成功&quot;;    ctx.status = res.code = 200;    ctx.body = res;  &#125;&#125;\n\n接入七牛云Step1安装七牛云node SDK\nyarn add qiniu-sdk// npm install qiniu-sdk -S\n\nStep2创建配置文件配置七牛云密钥，地址\n// qiniu.json&#123;  &quot;accessKey&quot;: &quot;qcBPTKEQ-lRlS----------------------------&quot;,  &quot;secretKey&quot;: &quot;2JTyex6hA7Sw-----------------------------&quot;,  &quot;baseUrl&quot;: &quot;Host&quot;&#125;\n\nStep3获取七牛云Token\nimport qiniu from &quot;qiniu&quot;;import &#123; baseUrl, secretKey, accessKey &#125; from &quot;../../qiniu.json&quot;;private static qiniuToken() &#123;    const mac = new qiniu.auth.digest.Mac(accessKey, secretKey);    const options = &#123;      scope: &quot;Your scope name&quot;,      expires: 3600 * 24, // file erpire time    &#125;;    const putPolicy = new qiniu.rs.PutPolicy(options);    const uploadToken = putPolicy.uploadToken(mac);    return uploadToken;  &#125;\n\nStep4封装上传函数\nimport qiniu from &quot;qiniu&quot;;// Key文件名，localfile 本地文件路径// 注： 如果想传到对应文件夹下，可以在文件名前加 dirName/private static qiniuUpload(key: string, localFile: string) &#123;    const uploadToken = FileController.qiniuToken();    const config: any = new qiniu.conf.Config();    // 存储地区编号查询： https://developer.qiniu.com/kodo/1671/region-endpoint-fq    config.zone = qiniu.zone.Zone_z2;    const formUploader = new qiniu.form_up.FormUploader(config);    const putExtra = new qiniu.form_up.PutExtra();    return new Promise((resolve, reject) =&gt; &#123;      formUploader.putFile(        uploadToken,        key,        localFile,        putExtra,        (respErr, respBody, respInfo) =&gt; &#123;          if (respErr) &#123;            reject(respErr);          &#125; else &#123;            resolve(respBody);          &#125;        &#125;      );    &#125;);  &#125;\n\nStep5最后封装上传API暴露出去\n/** * 上传文件 * @param ctx */public static async upload(ctx: Context) &#123;  const response = new CommeResponse();  const &#123; file &#125; = ctx.request.files as any;  if (!file) &#123;    throw new Error(&quot;请选择文件！&quot;);  &#125; else if (Array.isArray(file)) &#123;    throw new Error(&quot;只支持单个文件！&quot;);  &#125;  const ext = extname(file.originalFilename);  const fileName = &quot;gallery/&quot; + +new Date() + ext;  const localFile = file.filepath;  try &#123;    const res: any = await FileController.qiniuUpload(fileName, localFile);    const url = baseUrl + res.key;    response.success = true;    response.msg = &quot;上传成功&quot;;    response.data = &#123;      url,    &#125;;    ctx.body = response;  &#125; catch (e) &#123;    throw new Error(&quot;上传图片失败&quot;);  &#125;&#125;\n\n顺带记录一下这里用到的全局异常捕获中间件import &#123; Context &#125; from &quot;vm&quot;;import CommeResponse from &quot;./entity/Response&quot;;export default function errorHandler() &#123;  return async (ctx: Context, next: Function) =&gt; &#123;    try &#123;      await next();    &#125; catch (error) &#123;      // 捕获到异常后自动返回通用数据格式      const res = new CommeResponse();      res.code = 500;      res.msg = error.message;      ctx.body = res;    &#125;  &#125;;&#125;","categories":["Nodejs"],"tags":["Mysql","Nodejs","Koa","七牛云"]}]