[{"title":"箭头函数与普通函数的区别","url":"/2022/03/24/Untitled/","content":"箭头函数都是匿名函数普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。\n// 具名函数function func()&#123;  // code&#125; // 匿名函数let func=function()&#123;  // code&#125;// 箭头函数全都是匿名函数let func=()=&gt;&#123;  // code&#125;\n\n箭头函数不能用于构造函数，不能被实例化普通函数可以用于构造函数，以此创建对象实例。\nthis指向的区别箭头函数本身不创建this，但是声明时会捕获当前所在的上下文的this。捕获的this无法改变，也就是是说call，apply，bind等方法都不能对箭头函数使用\nvar webName=&quot;捕获成功&quot;;let func=()=&gt;&#123;  console.log(this.webName);&#125;func(); // 捕获成功\n\n普通函数的this获取的是调用它的对象，构造函数的this为创建的对象实例本身箭头函数不绑定arguments，取而代之用rest参数…解决每一个普通函数调用后都具有一个arguments对象，用来存储实际传递的参数。但是箭头函数并没有此对象。\nfunction A(a)&#123;  console.log(arguments);&#125;A(1,2,3,4,5,8);  //  [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]let B = (b)=&gt;&#123;  console.log(arguments);&#125;B(2,92,32,32);   // Uncaught ReferenceError: arguments is not definedlet C = (...c) =&gt; &#123;  console.log(c);&#125;C(3,82,32,11323);  // [3, 82, 32, 11323]\n\n其他区别（1）箭头函数不能Generator函数，不能使用yeild关键字。（2）箭头函数不具有prototype原型对象。（3）箭头函数不具有super。（4）箭头函数不具有new.target。\n","categories":["Javascript"],"tags":["VanillaJs","ES6"]},{"title":"闭包的理解","url":"/2022/03/29/%E9%97%AD%E5%8C%85/","content":"问题function fun(n,o) &#123;  console.log(o)  return &#123;    fun:function(m)&#123;      return fun(m,n);    &#125;  &#125;;&#125;var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?//问:三行a,b,c的输出分别是什么？\n\n解析第一行var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\n\n分析：首先，这一行代码为“;”分割，所以，var a一旦定义，后续调用fun方法不会在改变本身，m,n的作用域也属于a，所以fun(0) &#x3D;&gt; undefined, 此时的a实际为：\nvar a = function fun(n,0) &#123;  console.log(0)  return &#123;    fun:function(m)&#123;      return fun(m,n);    &#125;  &#125;;&#125;\n\n所以不管是a.fun(x),输出的值都是0\n第二行var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\n\n分析：这一行为连续执行，所以每一次掉的fun都为上次执行返回的对象，也就是\n&#123;  fun: (m) &#123;    return fun(m,n)  &#125;&#125;\n\n其n的作用域总为上一次调用此方法传入的第一个参数，所以，答案为：\n// undefined,0,1,2\n\n第三行var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n\n第三行懒得说了，一样的道理\n","categories":["Javascript"],"tags":["VanillaJs"]},{"title":"map与foreach","url":"/2022/03/29/map%E4%B8%8E-foreach/","content":"区别？Array.forEach()改变原数组，Array.map()则不改变原数组，返回新对象，但在实践中，发现只有基础数据类型不会被改变，引用数据类型则还是会被改变。\n例:\nlet a = [1,2,3,4,5]a.map(n =&gt; &#123;  n = n * 2&#125;)console.log(a) // [1, 2, 3, 4, 5]let b = [&#123; a: 1 &#125;, &#123; a: 2 &#125;, &#123; a: 3 &#125;, &#123; a: 4 &#125;, &#123; a: 5 &#125;]b.map((v) =&gt; &#123;  v.a = v.a * 2&#125;)console.log(JSON.stringify(b)) // [&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:4&#125;,&#123;&quot;a&quot;:6&#125;,&#123;&quot;a&quot;:8&#125;,&#123;&quot;a&quot;:10&#125;]\n\n以下内容摘取CSDNmap():map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值\n也就是map()进行处理之后返回一个新的数组\n⚠️注意：map()方法不会对空数组进行检测\nmap方法不会改变原始数组\nforEach()\nforEach方法用于调用数组的每个元素，将元素传给回调函数\n⚠️注意： forEach对于空数组是不会调用回调函数的 ，\n没有返回一个新数组&amp;没有返回值\n应用场景：为一些相同的元素，绑定事件处理器！\n不可链式调用\n执行速度摘自CSDNjsPref是一个非常好的网站用来比较不同的JavaScript函数的执行速度。\n这里是forEach()和map()的测试结果：\n可以看到，在我到电脑上forEach()的执行速度比map()慢了70%。每个人的浏览器的执行结果会不一样。你可以使用下面的链接来测试一下: Map vs. forEach - jsPref。\nJavaScript太灵活了，出了BUG你也不知道，不妨接入Fundebug线上实时监控。\n函数式角度的理解\n如果你习惯使用函数是编程，那么肯定喜欢使用map()。因为forEach()会改变原始的数组的值，而map()会返回一个全新的数组，原本的数组不受到影响。\n哪个更好呢？\n取决于你想要做什么。\nforEach适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。\n理解map性能强于forEach，且能链式操作，forEach适合不改变数据，只想拿数据做一些判断时对数据做操作优先用map\n","categories":["Javascript"],"tags":["VanillaJs","Map","Foreach"]},{"title":"ES6 循环","url":"/2022/03/29/ES6-%E5%BE%AA%E7%8E%AF/","content":"// 循环下标或者key（for-in）  // do not actually do thisfor (var index in myArray) &#123;      console.log(myArray[index]);  &#125;    // 循环value（for-of）  for (var value of myArray) &#123;    console.log(value);  &#125;    // 甚至直接循环key和value，no problem  for (var [key, value] of phoneBookMap) &#123;    console.log(key + &quot;&#x27;s phone number is: &quot; + value);  &#125;  \n\n","categories":["Javascript"],"tags":["ES6"]}]